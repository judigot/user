#!/bin/bash

# Keep this file up-to-date as soon as it's sourced, so any functions you run
# in the current shell session come from the latest `.devrc`.
devrcSelfUpdateOnSource() {
    # CI should test the checked-out version deterministically (no network mutation).
    if [ -n "${GITHUB_ACTIONS:-}" ]; then
        return 1
    fi

    if [ "${SNIPPETSRC_SELF_UPDATE_ATTEMPTED:-}" = "true" ]; then
        return 1
    fi

    SNIPPETSRC_SELF_UPDATE_ATTEMPTED="true"
    export SNIPPETSRC_SELF_UPDATE_ATTEMPTED

    local cache_bust=""
    cache_bust=$(date +%s 2>/dev/null || echo "0")
    local url="https://raw.githubusercontent.com/judigot/user/main/.devrc?cachebust=$cache_bust"
    local tmp="$HOME/.devrc.tmp.$$"

    if ! command -v curl >/dev/null 2>&1; then
        return 1
    fi

    if ! curl -fsSL --connect-timeout 2 --max-time 5 "$url" -o "$tmp" 2>/dev/null; then
        rm -f "$tmp" 2>/dev/null || true
        return 1
    fi

    if [ ! -s "$tmp" ]; then
        rm -f "$tmp" 2>/dev/null || true
        return 1
    fi

    if [ -f "$HOME/.devrc" ] && cmp -s "$tmp" "$HOME/.devrc" 2>/dev/null; then
        rm -f "$tmp" 2>/dev/null || true
        return 1
    fi

    mv "$tmp" "$HOME/.devrc"

    SNIPPETSRC_SELF_UPDATED="true"
    export SNIPPETSRC_SELF_UPDATED

    # shellcheck source=/dev/null
    source "$HOME/.devrc"
    return 0
}

if devrcSelfUpdateOnSource; then
    return 0
fi

loadAliasFile() {
    shopt -s expand_aliases
    
    local alias_file=""
    
    if [ -f "$HOME/ALIAS" ]; then
        alias_file="$HOME/ALIAS"
    elif [ -n "${USER:-}" ] && [ -f "/c/Users/$USER/ALIAS" ]; then
        alias_file="/c/Users/$USER/ALIAS"
    elif [ -n "${USERNAME:-}" ] && [ -f "/c/Users/$USERNAME/ALIAS" ]; then
        alias_file="/c/Users/$USERNAME/ALIAS"
    else
        return 1
    fi
    
    local current_func=""
    while IFS= read -r line || [ -n "$line" ]; do
        line="${line%%#*}"
        line="${line#"${line%%[![:space:]]*}"}"
        line="${line%"${line##*[![:space:]]}"}"
        
        [ -z "$line" ] && {
            current_func=""
            continue
        }
        
        if [[ "$line" == *: ]]; then
            current_func="${line%:}"
            current_func="${current_func%"${current_func##*[![:space:]]}"}"
            current_func="${current_func#"${current_func%%[![:space:]]*}"}"
        elif [ -n "$current_func" ]; then
            alias "$line"="$current_func"
        fi
    done < "$alias_file"
}

loadDevrcModules() {
    local modules_dir="$HOME/.devrc.d"

    if [ ! -d "$modules_dir" ]; then
        return 0
    fi

    for module in "$modules_dir"/*.sh; do
        [ -f "$module" ] || continue
        # shellcheck source=/dev/null
        . "$module"
    done
}

loadDevrcModules

helloWorld() {
    local user=${USER:-$USERNAME}
    echo -e "\e[32mHello, $user!\e[0m"
}

updateCurrentBranch() {
    git merge origin/main
    git push
}

# Original raw URL (kept for reference)
# [ -z "$USER_REPO_URL" ] && readonly USER_REPO_URL="https://raw.githubusercontent.com/judigot/user/main"

# Download user repo to temp directory, returns the path
downloadUserRepoTemp() {
    local url="https://github.com/judigot/user/archive/refs/heads/main.zip"

    if ! command -v curl >/dev/null 2>&1; then
        printf '%s\n' "curl is required to download the repo." >&2
        return 1
    fi

    if ! command -v unzip >/dev/null 2>&1; then
        printf '%s\n' "unzip is required to extract the repo." >&2
        return 1
    fi

    local tmp_dir
    tmp_dir=$(mktemp -d "/tmp/user-repo.XXXXXXXX") || return 1

    local zip="$tmp_dir/user.zip"

    if ! curl -fsSL --retry 3 --retry-delay 1 "$url" -o "$zip" 2>/dev/null; then
        printf '%s\n' "Download failed" >&2
        rm -rf "$tmp_dir" 2>/dev/null || true
        return 1
    fi

    if ! unzip -q "$zip" -d "$tmp_dir" 2>/dev/null; then
        # `unzip` failures are commonly caused by an HTML response being saved instead of a zip.
        # Don't hide the failure behind a generic message.
        printf '%s\n' "Extract failed (downloaded archive could not be unzipped)" >&2
        rm -rf "$tmp_dir" 2>/dev/null || true
        return 1
    fi

    rm -f "$zip" 2>/dev/null || true

    printf '%s\n' "$tmp_dir/user-main"
}

syncDotfiles() {
    local manifest="$1"
    local src="$2"
    local cleanup_dir=""
    
    if [ -z "$src" ]; then
        src=$(downloadUserRepoTemp) || return 1
        cleanup_dir=$(dirname "$src")
    fi
    
    local manifest_path="$src/$manifest"
    
    if [ ! -f "$manifest_path" ]; then
        echo "Manifest file not found: $manifest_path"
        [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir"
        return 1
    fi
    
    # Sync only what's listed in the manifest (handle files without trailing newline)
    while IFS= read -r file || [ -n "$file" ]; do
        if [ -n "$file" ]; then
            if [ -f "$src/$file" ]; then
                if [ "$(dirname "$file")" != "." ]; then
                    mkdir -p "$HOME/$(dirname "$file")" 2>/dev/null || true
                fi
                cp "$src/$file" "$HOME/$file" 2>/dev/null || true
            elif [ -d "$src/$file" ]; then
                mkdir -p "$HOME/$(dirname "$file")" 2>/dev/null || true
                cp -r "$src/$file" "$HOME/$file" 2>/dev/null || true
            fi
        fi
    done < "$manifest_path"
    
    [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir"
    echo "Dotfiles synced to home directory."
}

syncIDEFiles() {
    local src="$1"
    local cleanup_dir=""
    
    if [ -z "$src" ]; then
        src=$(downloadUserRepoTemp) || return 1
        cleanup_dir=$(dirname "$src")
    fi
    
    local appdata="$HOME/AppData/Roaming"
    local cursor_user="$appdata/Cursor/User"
    local zed_dir="$appdata/Zed"
    
    mkdir -p "$cursor_user/snippets" "$zed_dir"
    
    # Original: curl -sL "$USER_REPO_URL/ide/cursor/..." -o "..."
    cp "$src/ide/cursor/settings.jsonc" "$cursor_user/settings.json"
    cp "$src/ide/cursor/keybindings.jsonc" "$cursor_user/keybindings.json"
    cp "$src/ide/cursor/Master of Snippets.code-snippets" "$cursor_user/snippets/Master of Snippets.code-snippets"
    cp "$src/ide/zed/settings.jsonc" "$zed_dir/settings.json"
    cp "$src/ide/zed/keymap.jsonc" "$zed_dir/keymap.json"
    
    [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir"
    echo "IDE files synced."
}

syncUbuntu() {
    local manifest="$1"
    local src="$2"
    local cleanup_dir=""
    local wsl_root="//wsl.localhost/Ubuntu/root"
    local wsl_user="//wsl.localhost/Ubuntu/home/$USER"
    
    if [ ! -d "$wsl_root" ]; then
        echo "WSL Ubuntu not accessible, skipping."
        return 0
    fi
    
    if [ -z "$src" ]; then
        src=$(downloadUserRepoTemp) || return 1
        cleanup_dir=$(dirname "$src")
    fi
    
    local manifest_path="$src/$manifest"
    
    if [ ! -f "$manifest_path" ]; then
        echo "Manifest file not found: $manifest_path"
        [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir"
        return 1
    fi
    
    # Function to sync a single entry
    sync_entry() {
        local entry="$1"
        local dest_base="$2"
        
        # If entry starts with $HOME, it's a Windows path to sync to WSL home
        if echo "$entry" | grep -q '^\$HOME'; then
            # Expand $HOME and convert Windows path format
            local win_path=$(echo "$entry" | sed "s|\$HOME|$HOME|g" | sed 's|\\|/|g')
            # Extract just the relative path from $HOME (e.g., .ssh from $HOME\.ssh)
            local rel_path=$(echo "$entry" | sed 's|^\$HOME[\\/]*||' | sed 's|\\|/|g')
            local wsl_dest="$dest_base/$rel_path"
            
            # Copy from Windows to WSL
            if [ -d "$win_path" ]; then
                # Copy contents into destination (merge, don't replace)
                mkdir -p "$wsl_dest" 2>/dev/null || true
                cp -r "$win_path/." "$wsl_dest/" 2>/dev/null || true
            elif [ -f "$win_path" ]; then
                mkdir -p "$(dirname "$wsl_dest")" 2>/dev/null || true
                cp "$win_path" "$wsl_dest" 2>/dev/null || true
            fi
        else
            # Regular file from repo
            if [ -d "$src/$entry" ]; then
                mkdir -p "$dest_base/$entry" 2>/dev/null || true
                cp -r "$src/$entry/." "$dest_base/$entry/" 2>/dev/null || true
            elif [ -f "$src/$entry" ]; then
                mkdir -p "$dest_base/$(dirname "$entry")" 2>/dev/null || true
                cp "$src/$entry" "$dest_base/$entry" 2>/dev/null || true
            fi
        fi
    }
    
    # Sync only what's listed in the manifest (handle files without trailing newline)
    while IFS= read -r file || [ -n "$file" ]; do
        [ -n "$file" ] && sync_entry "$file" "$wsl_root"
    done < "$manifest_path"
    
    # Sync to user home if available
    if [ -d "$wsl_user" ]; then
        while IFS= read -r file || [ -n "$file" ]; do
            [ -n "$file" ] && sync_entry "$file" "$wsl_user"
        done < "$manifest_path"
    fi
    
    [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir"
    echo "Ubuntu WSL synced."
}

sourceShellConfig() {
    # Source the appropriate configuration based on the current shell
    if [[ "$0" == *"zsh"* ]]; then
        [[ -f "$HOME/.zshrc" ]] && source "$HOME/.zshrc"
    elif [[ "$0" == *"bash"* ]]; then
        [[ -f "$HOME/.bashrc" ]] && source "$HOME/.bashrc"
    fi

    # Source the shared snippets configuration
    [[ -f "$HOME/.devrc" ]] && source "$HOME/.devrc"
}

syncSnippetsrcAndAliasFromRemote() {
    if [ -n "${GITHUB_ACTIONS:-}" ] && [ -n "${GITHUB_WORKSPACE:-}" ] && [ -f "$GITHUB_WORKSPACE/.devrc" ] && [ -f "$GITHUB_WORKSPACE/ALIAS" ]; then
        cp "$GITHUB_WORKSPACE/.devrc" "$HOME/.devrc" && cp "$GITHUB_WORKSPACE/ALIAS" "$HOME/ALIAS"
        return $?
    fi

    if ! command -v bash >/dev/null 2>&1; then
        printf '%s\n' "bash is required to run load-devrc.sh" >&2
        return 1
    fi

    if ! command -v curl >/dev/null 2>&1; then
        printf '%s\n' "curl is required to download load-devrc.sh" >&2
        return 1
    fi

    local cache_bust=""
    cache_bust=$(date +%s 2>/dev/null || echo "0")
    local load_devrc_url="https://raw.githubusercontent.com/judigot/user/main/load-devrc.sh?cachebust=$cache_bust"

    if bash -c ". <(curl -fsSL \"$load_devrc_url\") -- --no-bashrc" >/dev/null 2>&1; then
        return 0
    fi

    if command -v downloadGithubFiles >/dev/null 2>&1; then
        if downloadGithubFiles judigot/user ".devrc" "ALIAS" ".devrc.d/opencode.sh" --dest "$HOME" --branch "main" >/dev/null 2>&1; then
            return 0
        fi
    fi

    if ! curl -fsSL "https://raw.githubusercontent.com/judigot/user/main/.devrc?cachebust=$cache_bust" -o "$HOME/.devrc"; then
        return 1
    fi

    if ! curl -fsSL "https://raw.githubusercontent.com/judigot/user/main/ALIAS?cachebust=$cache_bust" -o "$HOME/ALIAS"; then
        return 1
    fi

    mkdir -p "$HOME/.devrc.d" 2>/dev/null || true
    curl -fsSL "https://raw.githubusercontent.com/judigot/user/main/.devrc.d/opencode.sh?cachebust=$cache_bust" \
        -o "$HOME/.devrc.d/opencode.sh"
}

updateUserEnv() {
    isWindowsLikeShell() {
        case "$(uname -s 2>/dev/null)" in
            MINGW*|MSYS*|CYGWIN*) return 0 ;;
            *) return 1 ;;
        esac
    }

    hasApportableRoot() {
        if isWindowsLikeShell && [ -d "C:/apportable" ]; then
            return 0
        fi

        [ -d "/c/apportable" ] || [ -d "/mnt/c/apportable" ]
    }

    # Self-heal: even old versions of `.devrc` should be able to pull the latest
    # updater logic from GitHub, then re-run once using the refreshed definitions.
    if [ "${UPDATER_SELF_REFRESHED:-}" != "true" ]; then
        if syncSnippetsrcAndAliasFromRemote; then
            UPDATER_SELF_REFRESHED="true"
            export UPDATER_SELF_REFRESHED

            # shellcheck source=/dev/null
            . "$HOME/.devrc"

            updateUserEnv "$@"
            return $?
        fi
    fi

    # Non-Windows: keep terminal files fresh via load-devrc.sh
    if ! isWindowsLikeShell; then
        if syncSnippetsrcAndAliasFromRemote; then
            # shellcheck source=/dev/null
            [ -f "$HOME/.devrc" ] && source "$HOME/.devrc"
        fi

        echo "Terminal files updated and sourced successfully."
        return 0
    fi

    # If Apportable isn't present, only refresh terminal essentials (no .bashrc writes).
    if ! hasApportableRoot; then
        if ! downloadGithubFiles judigot/user ".devrc" "ALIAS" --dest "$HOME" --branch "main" >/dev/null 2>&1; then
            syncSnippetsrcAndAliasFromRemote || true
        fi
        sourceShellConfig
        echo "Terminal files updated and sourced successfully."
        return 0
    fi

    local src
    src=$(downloadUserRepoTemp) || {
        # If the full repo archive can't be downloaded/unzipped, fall back to raw-per-file
        # syncing so incomplete Windows machines still get the commit-and-sync style behavior.
        syncSnippetsrcAndAliasFromRemote || true

        # Dotfiles (exclude terminal files since they are managed separately)
        downloadGithubFiles judigot/user ".bash_profile" ".profile" ".zshrc" "profile.ps1" "PATH" "Apportable.ps1" "Apportable.sh" --dest "$HOME" --branch "main" >/dev/null 2>&1 || true

        # IDE files into AppData
        mkdir -p "$HOME/AppData/Roaming/Cursor/User/snippets" "$HOME/AppData/Roaming/Zed" 2>/dev/null || true
        downloadGithubFiles judigot/user "ide/cursor/settings.jsonc" "ide/cursor/keybindings.jsonc" "ide/cursor/Master of Snippets.code-snippets" --dest "/tmp/ide-tmp" --branch "main" >/dev/null 2>&1 || true
        downloadGithubFiles judigot/user "ide/zed/settings.jsonc" "ide/zed/keymap.jsonc" --dest "/tmp/ide-tmp" --branch "main" >/dev/null 2>&1 || true

        cp "/tmp/ide-tmp/ide/cursor/settings.jsonc" "$HOME/AppData/Roaming/Cursor/User/settings.json" 2>/dev/null || true
        cp "/tmp/ide-tmp/ide/cursor/keybindings.jsonc" "$HOME/AppData/Roaming/Cursor/User/keybindings.json" 2>/dev/null || true
        cp "/tmp/ide-tmp/ide/cursor/Master of Snippets.code-snippets" "$HOME/AppData/Roaming/Cursor/User/snippets/Master of Snippets.code-snippets" 2>/dev/null || true
        cp "/tmp/ide-tmp/ide/zed/settings.jsonc" "$HOME/AppData/Roaming/Zed/settings.json" 2>/dev/null || true
        cp "/tmp/ide-tmp/ide/zed/keymap.jsonc" "$HOME/AppData/Roaming/Zed/keymap.json" 2>/dev/null || true
        rm -rf "/tmp/ide-tmp" 2>/dev/null || true

        sourceShellConfig
        echo "Updater fallback: synced via raw downloads, repo zip unavailable."
        return 0
    }

    # Apportable exists: avoid overwriting terminal files. Keep any Windows-specific
    # terminal customization intact, while still syncing other dotfiles.
    local dotfiles_manifest_in="$src/DOTFILES"
    local dotfiles_manifest_tmp="$src/.dotfiles.no-terminal.$$"

    if [ -f "$dotfiles_manifest_in" ]; then
        awk '
            $0 != ".bashrc" && $0 != ".devrc" && $0 != "ALIAS" && $0 != "" { print $0 }
        ' "$dotfiles_manifest_in" > "$dotfiles_manifest_tmp"
        syncDotfiles "$(basename "$dotfiles_manifest_tmp")" "$src"
    else
        syncDotfiles "DOTFILES" "$src"
    fi
    syncIDEFiles "$src"
    syncUbuntu "UBUNTU" "$src"

    rm -rf "$(dirname "$src")"

    sourceShellConfig
    echo "Configuration files updated and sourced successfully."
}

updaterFull() {
    local choices=("Yes, overwrite ~/.bashrc" "No, cancel")
    local selected

    selected=$(arrowKeySelect "Do you own this machine or have permission to overwrite ~/.bashrc?" "${choices[@]}")

    if [ -z "$selected" ] || [ "$selected" = "No, cancel" ]; then
        printf '%s\n' "Updater cancelled."
        return 130
    fi

    updateUserEnv "$@" || return $?

    local cache_bust=""
    cache_bust=$(date +%s 2>/dev/null || echo "0")
    if ! curl -fsSL "https://raw.githubusercontent.com/judigot/user/main/.bashrc?cachebust=$cache_bust" -o "$HOME/.bashrc"; then
        printf '%s\n' "Failed to download .bashrc" >&2
        return 1
    fi

    # shellcheck source=/dev/null
    source "$HOME/.bashrc"

    printf '%s\n' "Full update complete."
}

bigBangVite() {
    local cache_bust=""
    cache_bust=$(date +%s 2>/dev/null || echo "0")
    curl -L "https://raw.githubusercontent.com/judigot/user/main/BigBangVite.sh?cachebust=$cache_bust" | bash
}

bigBangLaravel() {
    local cache_bust=""
    cache_bust=$(date +%s 2>/dev/null || echo "0")
    curl -L "https://raw.githubusercontent.com/judigot/user/main/BigBangLaravel.sh?cachebust=$cache_bust" | bash
}

logSSH() {
    echo -e "Copy and paste the public key below to your GitHub account:\n\n\e[32m$(cat ~/.ssh/id_ed25519.pub) \e[0m\n" # Green
}

generateSSHKey() {
    ssh-keygen -t rsa -f ~/.ssh/id_ed25519 -P "" && clear && logSSH
    ssh-keygen -t rsa -f ~/.ssh/id_ed25519 -P "" && chmod 600 ~/.ssh/id_ed25519 && clear && echossh
}

testSSH() {
    ssh -T git@github.com -o StrictHostKeyChecking=no
}

useSSHKey() {
  key="$1"

  # Start agent if needed
  if [ -z "${SSH_AUTH_SOCK:-}" ] || ! ssh-add -l >/dev/null 2>&1; then
    eval "$(ssh-agent -s)" >/dev/null
  fi

  # Reset keys, then add personal
  ssh-add -D >/dev/null 2>&1 || true
  ssh-add "$HOME/.ssh/$key"

  # Quick confirmation
  ssh-add -l
}

installAWS() {
    # Ubuntu/Debian
    sudo apt install -y awscli
}

copySSHDefaultKey() {
    local source_key="$1"
    local source_path="$HOME/.ssh/$source_key"
    local target_path="$HOME/.ssh/id_ed25519"

    mkdir -p "$HOME/.ssh" 2>/dev/null || true
    chmod 700 "$HOME/.ssh" 2>/dev/null || true

    if [ ! -f "$source_path" ]; then
        echo "✗ SSH key not found: $source_path" >&2
        return 1
    fi

    cp "$source_path" "$target_path"
    chmod 600 "$target_path" 2>/dev/null || true

    if [ -f "${source_path}.pub" ]; then
        cp "${source_path}.pub" "${target_path}.pub"
        chmod 644 "${target_path}.pub" 2>/dev/null || true
    else
        ssh-keygen -y -f "$target_path" > "${target_path}.pub" 2>/dev/null && \
            chmod 644 "${target_path}.pub" 2>/dev/null || true
    fi
}

usePersonalSSH() { copySSHDefaultKey "id_ed25519_personal" && useSSHKey "id_ed25519" && testSSH; }

useWorkSSH() { copySSHDefaultKey "id_ed25519_work" && useSSHKey "id_ed25519" && testSSH; }

deleteAll() {
    read -rp 'Are you sure you want to delete everything? (y/N) ' confirm
    [ "$confirm" = 'y' ] && rm -rf .[!.]* *
}

loadSnippets() {
    grep -q '#<DEVRC>' "$HOME/.bashrc" 2>/dev/null || printf '%s\n' '#<DEVRC>' '[[ -f "$HOME/.devrc" ]] && source "$HOME/.devrc"' '#</DEVRC>' >> "$HOME/.bashrc"
}

installOpenCodeConfigFromBitwarden() {
    local target="$HOME/.config/opencode/opencode.json"

    if [ -f "$target" ]; then
        return 0
    fi

    local choices=("No, skip" "Yes, install OpenCode config")
    local selected
    selected=$(arrowKeySelect "Install OpenCode settings from Bitwarden?" "${choices[@]}")

    if [ -z "$selected" ] || [ "$selected" = "No, skip" ]; then
        return 0
    fi

    if ! command -v bw >/dev/null 2>&1; then
        echo "✗ Bitwarden CLI (bw) is required to install OpenCode config." >&2
        return 1
    fi

    if ! bw --version >/dev/null 2>&1; then
        echo "✗ Bitwarden CLI found but cannot execute. Please reinstall it." >&2
        return 1
    fi

    if ! command -v node >/dev/null 2>&1; then
        echo "✗ Node.js is required to read Bitwarden notes." >&2
        return 1
    fi

    bw login --check >/dev/null 2>&1 || bw login
    export BW_SESSION="$(bw unlock --raw)"
    [ -n "$BW_SESSION" ] || { echo "✗ Failed to unlock Bitwarden vault" >&2; return 1; }

    bw sync >/dev/null 2>&1

    local note_name="Context7 API Key"
    local item_id
    item_id="$(bw list items --search "$note_name" 2>/dev/null | node -e "
        const input = require('fs').readFileSync(0, 'utf-8').trim();
        if (!input) process.exit(1);
        const data = JSON.parse(input);
        const match = data.find(i => i && i.name === process.argv[1] && i.type === 2);
        if (match) console.log(match.id);
        else process.exit(1);
    " "$note_name" 2>/dev/null)"

    [ -n "$item_id" ] || { echo "✗ Bitwarden note not found: $note_name" >&2; return 1; }

    local api_key
    api_key="$(bw get item "$item_id" 2>/dev/null | node -e "
        const data = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
        if (data.notes) console.log(String(data.notes).trim());
    " 2>/dev/null)"

    [ -n "$api_key" ] || { echo "✗ Context7 API key missing in Bitwarden note." >&2; return 1; }

    local template=""
    local cleanup_dir=""

    if [ -f "./.config/opencode/opencode.json" ]; then
        template="./.config/opencode/opencode.json"
    else
        local repo_dir
        repo_dir=$(downloadUserRepoTemp) || return 1
        cleanup_dir=$(dirname "$repo_dir")
        template="$repo_dir/.config/opencode/opencode.json"
    fi

    if [ ! -f "$template" ]; then
        [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir" 2>/dev/null || true
        echo "✗ OpenCode template not found: $template" >&2
        return 1
    fi

    local tmp_file="/tmp/opencode.json.$$"
    CONTEXT7_API_KEY="$api_key" node -e "
        const fs = require('fs');
        const template = fs.readFileSync(process.argv[1], 'utf-8');
        const key = process.env.CONTEXT7_API_KEY || '';
        if (!key) process.exit(1);
        process.stdout.write(template.replace('__CONTEXT7_API_KEY__', key));
    " "$template" > "$tmp_file" 2>/dev/null || {
        rm -f "$tmp_file" 2>/dev/null || true
        [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir" 2>/dev/null || true
        echo "✗ Failed to build OpenCode config" >&2
        return 1
    }

    mkdir -p "$HOME/.config/opencode" 2>/dev/null || true
    mv "$tmp_file" "$target"

    [ -n "$cleanup_dir" ] && rm -rf "$cleanup_dir" 2>/dev/null || true

    echo "✓ OpenCode config installed"
}

installOpenCode() {
    if ! command -v npm >/dev/null 2>&1; then
        echo "npm is required to install Open Code (opencode-ai)." >&2
        return 1
    fi

    npm i -g opencode-ai || return 1

    if [ ! -f "$HOME/.config/opencode/opencode.json" ]; then
        installOpenCodeConfigFromBitwarden || true
    fi
}

installClaudeCode() {
    case "$(uname -s)" in
        Linux*|Darwin*)
            curl -fsSL https://claude.ai/install.sh | bash
            ;;
        MINGW*|MSYS*|CYGWIN*)
            # Windows workaround (official installer is corrupted)
            powershell.exe -Command '
                $GCS_BUCKET = "https://storage.googleapis.com/claude-code-dist-86c565f3-f756-42ad-8dfa-d59b1c096819/claude-code-releases"
                $version = Invoke-RestMethod -Uri "$GCS_BUCKET/stable"
                $platform = "win32-x64"
                New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\.local\bin" | Out-Null
                Invoke-WebRequest -Uri "$GCS_BUCKET/$version/$platform/claude.exe" -OutFile "$env:USERPROFILE\.local\bin\claude.exe"
                Write-Host "Installed claude.exe to ~/.local/bin/"
            '
            ;;
        *)
            echo "Unsupported OS: $(uname -s)"
            return 1
            ;;
    esac
}

installCodexCLI() {
    if ! command -v npm >/dev/null 2>&1; then
        echo "npm is required to install Codex CLI." >&2
        return 1
    fi

    npm i -g @openai/codex
}

initUbuntu() {
    set -eu
    sudo apt-get update -y
    sudo apt-get upgrade -y
    sudo apt-get install -y ca-certificates curl git openssh-client zip unzip vim make fzf
}

loginUbuntu() {
    if command -v proot-distro >/dev/null 2>&1; then
        proot-distro login ubuntu
    elif command -v wsl >/dev/null 2>&1; then
        wsl -d Ubuntu
    elif command -v ubuntu.exe >/dev/null 2>&1; then
        ubuntu.exe
    else
        echo "Ubuntu not found. For Termux: install proot-distro and run 'proot-distro install ubuntu'. For Windows: install Ubuntu from Microsoft Store or use 'wsl --install -d Ubuntu'." >&2
        return 1
    fi
}

installTerraform() {
    if command -v terraform >/dev/null 2>&1; then
        terraform version
        return 0
    fi

    if ! command -v apt-get >/dev/null 2>&1; then
        echo "Terraform install requires apt-get (Debian/Ubuntu). For Windows/MSYS2, install via your Apportable setup instead." >&2
        return 1
    fi

    if ! command -v sudo >/dev/null 2>&1; then
        echo "Terraform install requires sudo." >&2
        return 1
    fi

    if ! command -v curl >/dev/null 2>&1; then
        echo "Terraform install requires curl." >&2
        return 1
    fi

    sudo apt-get update \
        && sudo apt-get install -y ca-certificates curl gnupg \
        && . /etc/os-release \
        && curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg \
        && echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com ${VERSION_CODENAME} main" | sudo tee /etc/apt/sources.list.d/hashicorp.list >/dev/null \
        && sudo apt-get update \
        && sudo apt-get install -y terraform
}

cloneUserRepo() {
    mkdir -p "$HOME/.apportable"
    git clone git@github.com:judigot/user.git "$HOME/.apportable/user"
}

cloneTerraformRepo() {
    git clone git@github.com:judigot/terraform.git "$HOME/terraform"
    cd "$HOME/terraform"
    terraform init
    pnpm install
}


# Simple arrow key selector (no external dependencies)
arrowKeySelect() {
    local prompt="$1"
    shift
    local choices=("$@")
    local selected=0
    local lines=$((${#choices[@]} + 1))
    
    # Hide cursor
    printf '\033[?25l' >&2
    
    while true; do
        # Clear previous menu (move up lines and clear)
        printf '\033[%dA\r' "$lines" >&2
        printf '\033[J' >&2
        
        # Display prompt
        printf '%s\n' "$prompt" >&2
        
        # Display choices with > for selected
        for i in "${!choices[@]}"; do
            if [ $i -eq $selected ]; then
                printf '  \033[7m> %s\033[0m\n' "${choices[$i]}" >&2
            else
                printf '    %s\n' "${choices[$i]}" >&2
            fi
        done
        
        # Read single character (including escape sequences)
        local key
        IFS= read -rsn1 key 2>/dev/null || break
        
        # Check for escape sequence (arrow keys)
        if [ "$key" = $'\033' ]; then
            IFS= read -rsn2 key 2>/dev/null
            case "$key" in
                '[A') # Up arrow
                    [ $selected -gt 0 ] && selected=$((selected - 1))
                    ;;
                '[B') # Down arrow
                    [ $selected -lt $((${#choices[@]} - 1)) ] && selected=$((selected + 1))
                    ;;
            esac
        elif [ "$key" = "" ]; then
            # Enter key
            break
        elif [ "$key" = "q" ] || [ "$key" = "Q" ]; then
            # Quit
            selected=-1
            break
        elif [[ "$key" =~ ^[1-9]$ ]]; then
            # Number selection (1-based)
            local num=$((key - 1))
            if [ $num -lt ${#choices[@]} ]; then
                selected=$num
                break
            fi
        fi
    done
    
    # Clear menu and show cursor
    printf '\033[%dA\r' "$lines" >&2
    printf '\033[J' >&2
    printf '\033[?25h' >&2
    
    if [ $selected -ge 0 ] && [ $selected -lt ${#choices[@]} ]; then
        printf '%s\n' "${choices[$selected]}"
        return 0
    else
        return 1
    fi
}

applyGitCredentials() {
    local note_name="$1"

    # Must have bw and BW_SESSION already set
    command -v bw >/dev/null 2>&1 || return 1
    [ -n "$BW_SESSION" ] || return 1

    # Sync vault to ensure latest data
    bw sync >/dev/null 2>&1

    # Find the secure note (type 2 = secure note)
    local item_id
    item_id="$(bw list items --search "$note_name" 2>/dev/null | node -e "
        const input = require('fs').readFileSync(0, 'utf-8').trim();
        if (!input) process.exit(1);
        const data = JSON.parse(input);
        const match = data.find(i => i && i.name === process.argv[1] && i.type === 2);
        if (match) console.log(match.id);
        else process.exit(1);
    " "$note_name" 2>/dev/null)"

    [ -n "$item_id" ] || return 1

    # Get the notes content
    local notes
    notes="$(bw get item "$item_id" 2>/dev/null | node -e "
        const data = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
        if (data.notes) console.log(data.notes);
    " 2>/dev/null)"

    [ -n "$notes" ] || return 1

    # Execute each git config line (skip --list and --get commands)
    while IFS= read -r line || [ -n "$line" ]; do
        line="${line#"${line%%[![:space:]]*}"}"
        if [ -n "$line" ] && [[ "$line" == git\ config* ]]; then
            [[ "$line" == *--list* ]] && continue
            [[ "$line" == *--get* ]] && continue
            eval "$line" >/dev/null 2>&1
        fi
    done <<< "$notes"

    echo "✓ Applied: $note_name"
}

useSSH() {
    # Load nvm if available (needed for npm on Linux/Ubuntu)
    if [ -s "$HOME/.nvm/nvm.sh" ]; then
        export NVM_DIR="$HOME/.nvm"
        # shellcheck source=/dev/null
        . "$NVM_DIR/nvm.sh"
        # shellcheck source=/dev/null
        [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"
    fi
    
    # Ensure ~/.local/bin and npm global bin are in PATH (needed for Termux/Ubuntu user installs)
    npm_prefix="$(npm config get prefix 2>/dev/null || echo "$HOME/.local")"
    export PATH="$npm_prefix/bin:$HOME/.local/bin:$PATH"
    mkdir -p "$HOME/.local/bin" 2>/dev/null || true

    # Check if bw exists but can't execute (wrong architecture issue)
    # Remove broken binaries from all possible locations and clear command cache
    if command -v bw >/dev/null 2>&1; then
        if ! bw --version >/dev/null 2>&1; then
            echo "⚠ Bitwarden CLI binary found but cannot execute (wrong architecture). Removing..." >&2
            bw_path="$(command -v bw)"
            [ -f "$bw_path" ] && rm -f "$bw_path" 2>/dev/null || true
            [ -f "/usr/local/bin/bw" ] && sudo rm -f /usr/local/bin/bw 2>/dev/null || rm -f /usr/local/bin/bw 2>/dev/null || true
            [ -f "$HOME/.local/bin/bw" ] && rm -f "$HOME/.local/bin/bw" 2>/dev/null || true
            hash -r 2>/dev/null || true  # Clear command cache
        fi
    fi
    
    # Also proactively remove broken binary if it exists at known locations (even if not in PATH)
    if [ -f "/usr/local/bin/bw" ] && ! /usr/local/bin/bw --version >/dev/null 2>&1; then
        echo "⚠ Removing broken Bitwarden CLI from /usr/local/bin..." >&2
        sudo rm -f /usr/local/bin/bw 2>/dev/null || rm -f /usr/local/bin/bw 2>/dev/null || true
        hash -r 2>/dev/null || true
    fi

    setupSSHFromBitwarden() {
        # Install Bitwarden CLI if needed
        if ! command -v bw >/dev/null 2>&1 || ! bw --version >/dev/null 2>&1; then
            if ! command -v npm >/dev/null 2>&1; then
                echo "✗ Node.js/npm is required to install Bitwarden CLI" >&2
                echo "  Please install Node.js first: run 'installnodeenv' or install npm manually" >&2
                return 1
            fi

            npm_prefix="$(npm config get prefix 2>/dev/null || echo "$HOME/.local")"
            export PATH="$npm_prefix/bin:$PATH"

            echo "Installing Bitwarden CLI via npm..." >&2
            if ! npm install -g @bitwarden/cli >/dev/null 2>&1; then
                echo "✗ Failed to install Bitwarden CLI via npm" >&2
                return 1
            fi
        fi

        npm_prefix="$(npm config get prefix 2>/dev/null || echo "$HOME/.local")"
        export PATH="$npm_prefix/bin:$HOME/.local/bin:/usr/local/bin:$PATH"
        hash -r 2>/dev/null || true

        bw login --check >/dev/null 2>&1 || bw login
        export BW_SESSION="$(bw unlock --raw)"
        [ -n "$BW_SESSION" ] || { echo "✗ Failed to unlock Bitwarden vault" >&2; return 1; }

        if ! command -v node >/dev/null 2>&1; then
            echo "✗ Node.js not found. Please install Node.js to use this function." >&2
            return 1
        fi

        process_ssh_key() {
            local ITEM_NAME="$1"

            echo ""
            echo "=== Processing: $ITEM_NAME ==="

            item_id="$(bw list items 2>/dev/null | node -e "
                try {
                    const normalize = (s) => s ? s.toLowerCase().replace(/[\\s_-]+/g, '').trim() : '';
                    const searchTerm = normalize(process.argv[1]);
                    const input = require('fs').readFileSync(0, 'utf-8').trim();
                    if (!input) process.exit(1);
                    const data = JSON.parse(input);
                    if (!Array.isArray(data)) process.exit(1);

                    const sshItems = data.filter(i => i && (i.type === 5 || (i.type === 4 && i.login)));
                    let matches = sshItems.filter(i => i.name && normalize(i.name) === searchTerm);

                    if (matches.length === 0) {
                        matches = sshItems.filter(i => i.name && normalize(i.name).includes(searchTerm));
                    }

                    if (matches.length >= 1) {
                        console.log(matches[0].id);
                    } else {
                        process.exit(1);
                    }
                } catch (e) {
                    process.exit(1);
                }
            " "$ITEM_NAME")"

            [ -n "$item_id" ] || {
                echo "✗ Bitwarden item not found: $ITEM_NAME" >&2
                return 1
            }

            key_data="$(bw get item "$item_id" | node -e "
                const data = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
                const result = { privateKey: null, publicKey: null, keyType: null };

                if (data.type === 5 && data.sshKey) {
                    result.privateKey = data.sshKey.privateKey || null;
                    result.publicKey = data.sshKey.publicKey || null;
                    if (result.privateKey) result.privateKey = result.privateKey.replace(/\\\\n/g, '\\n');
                    if (result.publicKey) result.publicKey = result.publicKey.replace(/\\\\n/g, '\\n');
                }

                if (!result.privateKey && data.fields) {
                    const findField = (name) => data.fields.find(f => f && f.name && f.name.toLowerCase().includes(name));
                    const priv = findField('private');
                    const pub = findField('public');
                    if (priv && priv.value) result.privateKey = priv.value;
                    if (pub && pub.value) result.publicKey = pub.value;
                    if (result.privateKey) result.privateKey = result.privateKey.replace(/\\\\n/g, '\\n');
                    if (result.publicKey) result.publicKey = result.publicKey.replace(/\\\\n/g, '\\n');
                }

                if (result.privateKey) {
                    if (result.privateKey.includes('BEGIN OPENSSH PRIVATE KEY')) result.keyType = 'ed25519';
                    else if (result.privateKey.includes('BEGIN RSA PRIVATE KEY')) result.keyType = 'rsa';
                    else if (result.privateKey.includes('BEGIN EC PRIVATE KEY')) result.keyType = 'ecdsa';
                    else if (result.privateKey.includes('BEGIN DSA PRIVATE KEY')) result.keyType = 'dsa';
                }

                console.log(JSON.stringify(result));
            ")"

            private_key="$(echo "$key_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.privateKey || '')")"
            public_key="$(echo "$key_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.publicKey || '')")"
            key_type="$(echo "$key_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.keyType || 'ed25519')")"

            local KEY_FILENAME
            item_part="$(echo "$ITEM_NAME" | sed 's/^[Ss][Ss][Hh][[:space:]]*//' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^\-|-$//g')"
            if [ "$item_part" = "personal" ]; then
                KEY_FILENAME="id_${key_type}_personal"
            elif [ -z "$item_part" ]; then
                KEY_FILENAME="id_${key_type}"
            else
                KEY_FILENAME="id_${key_type}_${item_part}"
            fi


            if [ -z "$private_key" ] || [ "$private_key" = "null" ]; then
                echo "✗ Private key not found in item '$ITEM_NAME'" >&2
                return 1
            fi

            mkdir -p "$HOME/.ssh" && chmod 700 "$HOME/.ssh" 2>/dev/null || true
            printf '%s\n' "$private_key" > "$HOME/.ssh/$KEY_FILENAME"
            chmod 600 "$HOME/.ssh/$KEY_FILENAME" 2>/dev/null || true
            echo "✓ Private key saved: ~/.ssh/$KEY_FILENAME"

            if [ -n "$public_key" ] && [ "$public_key" != "null" ]; then
                printf '%s\n' "$public_key" > "$HOME/.ssh/${KEY_FILENAME}.pub"
                chmod 644 "$HOME/.ssh/${KEY_FILENAME}.pub" 2>/dev/null || true
                echo "✓ Public key saved: ~/.ssh/${KEY_FILENAME}.pub"
            else
                ssh-keygen -y -f "$HOME/.ssh/$KEY_FILENAME" > "$HOME/.ssh/${KEY_FILENAME}.pub" 2>/dev/null && \
                    chmod 644 "$HOME/.ssh/${KEY_FILENAME}.pub" 2>/dev/null && \
                    echo "✓ Public key generated: ~/.ssh/${KEY_FILENAME}.pub" || \
                    echo "⚠ Could not generate public key"
            fi

            [ "$(uname -s | tr '[:upper:]' '[:lower:]')" = "linux" ] && eval "$(ssh-agent -s)" >/dev/null 2>&1 || true
            ssh-add "$HOME/.ssh/$KEY_FILENAME"

            echo "✓ SSH key ready: ~/.ssh/$KEY_FILENAME"
        }

        for ITEM_NAME in "$@"; do
            process_ssh_key "$ITEM_NAME" || echo "⚠ Failed to process: $ITEM_NAME" >&2
        done
    }

    # Export PATH to ensure script sees ~/.local/bin
    export PATH="$HOME/.local/bin:$PATH"

    local selected=""

    # Default: set up both keys without prompting
    if [ $# -eq 0 ]; then
        selected="SSH Personal"
        setupSSHFromBitwarden "SSH Personal" "SSH Work"
    else
        selected="$1"
        setupSSHFromBitwarden "$@"
    fi

    if [ ! -f "$HOME/.ssh/id_ed25519_personal" ]; then
        echo "✗ Personal SSH key not found: ~/.ssh/id_ed25519_personal" >&2
        return 1
    fi

    if [ ! -f "$HOME/.ssh/id_ed25519_work" ]; then
        echo "✗ Work SSH key not found: ~/.ssh/id_ed25519_work" >&2
        return 1
    fi

    copySSHDefaultKey "id_ed25519_personal" || return 1

    # Ensure SSH directory and keys have proper permissions
    if [ -d "$HOME/.ssh" ]; then
        chmod 700 "$HOME/.ssh" 2>/dev/null || true
        # Set permissions on all private keys
        find "$HOME/.ssh" -type f -name "id_*" ! -name "*.pub" -exec chmod 600 {} \; 2>/dev/null || true
        # Set permissions on all public keys
        find "$HOME/.ssh" -type f -name "*.pub" -exec chmod 644 {} \; 2>/dev/null || true
    fi

    # Apply git configuration
    echo "Applying git configuration..."

    # Apply global git config from GitHub repo
    local git_settings="/tmp/GIT_SETTINGS.$$"
    if downloadGithubFiles judigot/user "GIT_SETTINGS" --dest "/tmp" --branch "main" >/dev/null 2>&1; then
        mv "/tmp/GIT_SETTINGS" "$git_settings" 2>/dev/null
        if [ -f "$git_settings" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                line="${line#"${line%%[![:space:]]*}"}"
                if [ -n "$line" ] && [[ "$line" == git\ config* ]]; then
                    [[ "$line" == *--list* ]] && continue
                    [[ "$line" == *--get* ]] && continue
                    eval "$line" >/dev/null 2>&1
                fi
            done < "$git_settings"
            rm -f "$git_settings"
            echo "✓ Applied: Git settings from GitHub"
        fi
    fi

    # Apply user-specific credentials from Bitwarden (overrides user.name/email)
    if command -v bw >/dev/null 2>&1 && bw --version >/dev/null 2>&1; then
        if bw login --check >/dev/null 2>&1; then
            export BW_SESSION="$(bw unlock --raw)"
            if [ -n "$BW_SESSION" ]; then
                if [ "$selected" = "SSH Work" ]; then
                    applyGitCredentials "Git Credentials Work"
                elif [ "$selected" = "SSH Personal" ]; then
                    applyGitCredentials "Git Credentials Personal"
                fi
            fi
        fi
    fi

    # Configure includeIf for automatic SSH key selection by folder
    local work_dir="$HOME/work"
    local personal_dir="$HOME/personal"
    mkdir -p "$work_dir" "$personal_dir" 2>/dev/null || true

    local ssh_config="$HOME/.ssh/config"
    local ssh_block_start="# BEGIN JUDIGOT SSH CONFIG"
    local ssh_block_end="# END JUDIGOT SSH CONFIG"
    local ssh_block="$ssh_block_start
Host github.com
  User git
  IdentityFile ~/.ssh/id_ed25519
  IdentitiesOnly yes
$ssh_block_end"

    if [ -f "$ssh_config" ]; then
        if grep -q "$ssh_block_start" "$ssh_config" 2>/dev/null; then
            awk -v start="$ssh_block_start" -v end="$ssh_block_end" -v block="$ssh_block" '
                $0 == start { print block; inblock=1; next }
                inblock && $0 == end { inblock=0; next }
                !inblock { print }
            ' "$ssh_config" > "${ssh_config}.tmp" && mv "${ssh_config}.tmp" "$ssh_config"
        else
            printf '\n%s\n' "$ssh_block" >> "$ssh_config"
        fi
    else
        printf '%s\n' "$ssh_block" > "$ssh_config"
    fi
    chmod 600 "$ssh_config" 2>/dev/null || true

    local gitconfig="$HOME/.gitconfig"
    local git_block_start="# BEGIN JUDIGOT INCLUDEIF"
    local git_block_end="# END JUDIGOT INCLUDEIF"
    local git_block="$git_block_start
[includeIf \"gitdir:$work_dir/\"]
  path = $HOME/.gitconfig-work
$git_block_end"

    if [ -f "$gitconfig" ]; then
        if grep -q "$git_block_start" "$gitconfig" 2>/dev/null; then
            awk -v start="$git_block_start" -v end="$git_block_end" -v block="$git_block" '
                $0 == start { print block; inblock=1; next }
                inblock && $0 == end { inblock=0; next }
                !inblock { print }
            ' "$gitconfig" > "${gitconfig}.tmp" && mv "${gitconfig}.tmp" "$gitconfig"
        else
            printf '\n%s\n' "$git_block" >> "$gitconfig"
        fi
    else
        printf '%s\n' "$git_block" > "$gitconfig"
    fi

    local gitconfig_work="$HOME/.gitconfig-work"
    printf '%s\n' "[core]" "  sshCommand = ssh -i $HOME/.ssh/id_ed25519_work -o IdentitiesOnly=yes" > "$gitconfig_work"

    echo "✓ Git configuration complete"
}

useAWS() {
    # Load nvm if available (needed for npm on Linux/Ubuntu)
    if [ -s "$HOME/.nvm/nvm.sh" ]; then
        export NVM_DIR="$HOME/.nvm"
        # shellcheck source=/dev/null
        . "$NVM_DIR/nvm.sh"
        # shellcheck source=/dev/null
        [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"
    fi
    
    # Ensure npm is in PATH
    npm_prefix="$(npm config get prefix 2>/dev/null || echo "$HOME/.local")"
    export PATH="$npm_prefix/bin:$HOME/.local/bin:$PATH"
    
    # Check if bw exists and is executable
    if ! command -v bw >/dev/null 2>&1; then
        echo "✗ Bitwarden CLI (bw) is required. Please run 'usessh' first to install it." >&2
        return 1
    fi
    
    if ! bw --version >/dev/null 2>&1; then
        echo "✗ Bitwarden CLI found but cannot execute. Please run 'usessh' first to reinstall it." >&2
        return 1
    fi
    
    # Check if logged in
    if ! bw login --check >/dev/null 2>&1; then
        echo "⚠ Not logged in to Bitwarden. Please login first..." >&2
        bw login || return 1
    fi
    
    # Check if vault is unlocked
    if ! bw unlock --check >/dev/null 2>&1; then
        echo "⚠ Bitwarden vault is locked. Please unlock..." >&2
        export BW_SESSION="$(bw unlock --raw)"
        [ -n "$BW_SESSION" ] || { echo "✗ Failed to unlock Bitwarden vault" >&2; return 1; }
    else
        export BW_SESSION="$(bw unlock --raw)"
    fi
    
    # Get AWS Credentials item
    echo "Fetching AWS Credentials from Bitwarden..." >&2
    item_id="$(bw list items 2>/dev/null | node -e "
        const normalize = (s) => s ? s.toLowerCase().replace(/[\\s_-]+/g, '').trim() : '';
        const searchTerm = normalize('AWS Credentials');
        const input = require('fs').readFileSync(0, 'utf-8').trim();
        if (!input) process.exit(1);
        const data = JSON.parse(input);
        if (!Array.isArray(data)) process.exit(1);
        const matches = data.filter(i => i && i.name && normalize(i.name) === searchTerm);
        if (matches.length === 1) {
            console.log(matches[0].id);
        } else if (matches.length > 1) {
            console.log(matches[0].id);
            console.error('Multiple matches found, using:', matches[0].name);
        } else {
            process.exit(1);
        }
    ")"
    
    if [ -z "$item_id" ]; then
        echo "✗ AWS Credentials item not found in Bitwarden vault" >&2
        return 1
    fi
    
    # Get item and extract credentials
    credentials_data="$(bw get item "$item_id" 2>/dev/null | node -e "
        const data = JSON.parse(require('fs').readFileSync(0, 'utf-8'));
        let result = { awsAccessKeyId: null, awsSecretAccessKey: null, credentialsText: null };
        
        // Try to get from fields first
        if (data.fields && data.fields.length > 0) {
            data.fields.forEach(f => {
                const name = (f.name || '').toLowerCase();
                if (name.includes('access') && name.includes('key') && name.includes('id')) {
                    result.awsAccessKeyId = f.value;
                } else if (name.includes('secret') && name.includes('access') && name.includes('key')) {
                    result.awsSecretAccessKey = f.value;
                }
            });
        }
        
        // Try to get from notes (might be stored as full credentials file format)
        if (data.notes) {
            result.credentialsText = data.notes;
        }
        
        // Try login.username and login.password as fallback
        if (!result.awsAccessKeyId && data.login && data.login.username) {
            result.awsAccessKeyId = data.login.username;
        }
        if (!result.awsSecretAccessKey && data.login && data.login.password) {
            result.awsSecretAccessKey = data.login.password;
        }
        
        console.log(JSON.stringify(result));
    ")"
    
    # Extract values
    aws_access_key_id="$(echo "$credentials_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.awsAccessKeyId || '')")"
    aws_secret_access_key="$(echo "$credentials_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.awsSecretAccessKey || '')")"
    credentials_text="$(echo "$credentials_data" | node -e "const d=JSON.parse(require('fs').readFileSync(0,'utf-8')); console.log(d.credentialsText || '')")"
    
    # Create AWS credentials directory
    mkdir -p "$HOME/.aws"
    chmod 700 "$HOME/.aws"
    
    # Write credentials file
    if [ -n "$credentials_text" ] && [ "$credentials_text" != "null" ]; then
        # Use the full credentials text if provided
        printf '%s\n' "$credentials_text" > "$HOME/.aws/credentials"
    elif [ -n "$aws_access_key_id" ] && [ "$aws_access_key_id" != "null" ] && [ -n "$aws_secret_access_key" ] && [ "$aws_secret_access_key" != "null" ]; then
        # Build credentials file from fields
        cat > "$HOME/.aws/credentials" <<EOF
[default]
aws_access_key_id = $aws_access_key_id
aws_secret_access_key = $aws_secret_access_key
EOF
    else
        echo "✗ Could not extract AWS credentials from Bitwarden item" >&2
        echo "  Expected fields: 'Access Key ID' and 'Secret Access Key', or credentials in Notes field" >&2
        return 1
    fi
    
    # Set proper permissions
    chmod 600 "$HOME/.aws/credentials" 2>/dev/null || true
    
    echo "✓ AWS credentials saved to ~/.aws/credentials"
}

setupNodeEnv() {
    local installed_something=false

    # Load nvm if it exists (needed for version display)
    case "$(uname -s 2>/dev/null)" in
        Linux*|Darwin*)
            local nvm_dir="$HOME/.nvm"
            if [ -s "$nvm_dir/nvm.sh" ]; then
                export NVM_DIR="$nvm_dir"
                [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" 2>/dev/null || true
            fi
            ;;
    esac

    # Display current versions immediately (instant feedback)
    if command -v nvm >/dev/null 2>&1; then
        case "$(uname -s 2>/dev/null)" in
            MINGW*|MSYS*|CYGWIN*)
                printf 'nvm: %s\n' "$(nvm version 2>/dev/null || echo 'N/A')"
                ;;
            *)
                printf 'nvm: %s\n' "$(nvm --version 2>/dev/null || echo 'N/A')"
                ;;
        esac
    else
        printf 'nvm: not installed\n'
    fi
    if command -v node >/dev/null 2>&1; then
        printf 'node: %s\n' "$(node --version 2>/dev/null || echo 'N/A')"
    else
        printf 'node: not installed\n'
    fi
    if command -v npm >/dev/null 2>&1; then
        printf 'npm: %s\n' "$(npm --version 2>/dev/null || echo 'N/A')"
    else
        printf 'npm: not installed\n'
    fi
    if command -v pnpm >/dev/null 2>&1; then
        printf 'pnpm: %s\n' "$(pnpm --version 2>/dev/null || echo 'N/A')"
    else
        printf 'pnpm: not installed\n'
    fi
    if command -v bun >/dev/null 2>&1; then
        printf 'bun: %s\n' "$(bun --version 2>/dev/null || echo 'N/A')"
    else
        printf 'bun: not installed\n'
    fi

    # Install node/npm if needed
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        installed_something=true
        if ! command -v curl >/dev/null 2>&1; then
            echo "Node environment setup requires curl." >&2
            return 1
        fi

        case "$(uname -s 2>/dev/null)" in
            MINGW*|MSYS*|CYGWIN*)
                # Windows/MSYS2: Use nvm-windows
                local root_dir="/c/apportable/Programming"
                local nvm_home="$root_dir/nvm"
                local nvm_symlink="$root_dir/nodejs"
                local nvm_zip_url="https://github.com/coreybutler/nvm-windows/releases/download/1.2.2/nvm-noinstall.zip"

                mkdir -p "$nvm_home" "$nvm_symlink" 2>/dev/null || true

                if ! command -v nvm >/dev/null 2>&1; then
                    local tmp_dir=""
                    tmp_dir=$(mktemp -d "/tmp/nvm-windows.XXXXXXXX" 2>/dev/null) || tmp_dir=""
                    [ -n "$tmp_dir" ] || { echo "Failed to create a temp directory." >&2; return 1; }

                    local zip="$tmp_dir/nvm-noinstall.zip"
                    if ! curl -fsSL --retry 3 --retry-delay 1 "$nvm_zip_url" -o "$zip" 2>/dev/null; then
                        rm -rf "$tmp_dir" 2>/dev/null || true
                        echo "Failed to download nvm-windows." >&2
                        return 1
                    fi

                    if command -v unzip >/dev/null 2>&1; then
                        unzip -o "$zip" -d "$nvm_home" >/dev/null 2>&1 || {
                            rm -rf "$tmp_dir" 2>/dev/null || true
                            echo "Failed to extract nvm-windows (unzip failed)." >&2
                            return 1
                        }
                    elif command -v powershell.exe >/dev/null 2>&1; then
                        powershell.exe -NoProfile -Command "Expand-Archive -Force -Path '$zip' -DestinationPath '$nvm_home'" >/dev/null 2>&1 || {
                            rm -rf "$tmp_dir" 2>/dev/null || true
                            echo "Failed to extract nvm-windows (Expand-Archive failed)." >&2
                            return 1
                        }
                    else
                        rm -rf "$tmp_dir" 2>/dev/null || true
                        echo "unzip (or powershell Expand-Archive) is required to extract nvm-windows." >&2
                        return 1
                    fi

                    rm -rf "$tmp_dir" 2>/dev/null || true
                fi

                export NVM_HOME="$nvm_home"
                export NVM_SYMLINK="$nvm_symlink"
                export PATH="$PATH:$NVM_HOME:$NVM_SYMLINK"

                : >"$NVM_HOME/PATH.txt"
                : >"$NVM_HOME/settings.txt"
                echo "PATH=$PATH" >"$NVM_HOME/PATH.txt"

                local sys_arch="64"
                [ -d "/c/Program Files (x86)" ] || sys_arch="32"
                echo "root: $NVM_HOME" >"$NVM_HOME/settings.txt"
                echo "path: $NVM_SYMLINK" >>"$NVM_HOME/settings.txt"
                echo "arch: $sys_arch" >>"$NVM_HOME/settings.txt"
                echo "proxy: none" >>"$NVM_HOME/settings.txt"

                nvm install --lts || return 1

                if [ -f "$root_dir/PortableGit/bin/bash.exe" ]; then
                    npm config set script-shell "$root_dir/PortableGit/bin/bash.exe" >/dev/null 2>&1 || true
                fi
                ;;
            Linux*)
                # Linux/Ubuntu: Use nvm (nvm-sh/nvm)
                local nvm_dir="$HOME/.nvm"
                
                # Install dependencies if needed (Ubuntu syntax)
                if ! command -v git >/dev/null 2>&1; then
                    echo "Installing git..." >&2
                    apt update >/dev/null 2>&1 && apt install -y git >/dev/null 2>&1 || {
                        echo "✗ Failed to install git. Please install manually: apt update && apt install -y git" >&2
                        return 1
                    }
                fi
                
                # Check if nvm is already installed
                if [ ! -s "$nvm_dir/nvm.sh" ]; then
                    echo "Installing nvm..." >&2
                    if curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash >/dev/null 2>&1; then
                        # Source nvm in current shell
                        export NVM_DIR="$nvm_dir"
                        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
                        [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
                    else
                        echo "✗ Failed to install nvm" >&2
                        return 1
                    fi
                else
                    # Source nvm if already installed
                    export NVM_DIR="$nvm_dir"
                    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
                    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
                fi

                # Install Node.js LTS (matching Apportable.sh syntax: nvm install --lts)
                echo "Installing Node.js LTS..." >&2
                nvm install --lts && nvm use --lts || return 1
                ;;
            Darwin*)
                # macOS: Use nvm (nvm-sh/nvm)
                local nvm_dir="$HOME/.nvm"
                
                # Check if nvm is already installed
                if [ ! -s "$nvm_dir/nvm.sh" ]; then
                    echo "Installing nvm..." >&2
                    if curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash >/dev/null 2>&1; then
                        # Source nvm in current shell
                        export NVM_DIR="$nvm_dir"
                        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
                        [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
                    else
                        echo "✗ Failed to install nvm" >&2
                        return 1
                    fi
                else
                    # Source nvm if already installed
                    export NVM_DIR="$nvm_dir"
                    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
                    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
                fi

                # Install Node.js LTS
                echo "Installing Node.js LTS..." >&2
                nvm install --lts && nvm use --lts || return 1
                nvm alias default lts/* >/dev/null 2>&1 || true
                ;;
            *)
                echo "Unsupported operating system: $(uname -s)" >&2
                return 1
                ;;
        esac
    fi

    # Ensure nvm is loaded (in case it was just installed)
    case "$(uname -s 2>/dev/null)" in
        Linux*|Darwin*)
            local nvm_dir="$HOME/.nvm"
            if [ -s "$nvm_dir/nvm.sh" ]; then
                export NVM_DIR="$nvm_dir"
                [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" 2>/dev/null || true
            fi
            ;;
    esac

    # Install global packages (matching Apportable.sh) - only if not already installed
    command -v bun >/dev/null 2>&1 || npm install -g bun >/dev/null 2>&1 || true
    command -v pnpm >/dev/null 2>&1 || npm install -g pnpm >/dev/null 2>&1 || true
    command -v pnpm >/dev/null 2>&1 && pnpm config set store-dir ~/.pnpm-store >/dev/null 2>&1 || true

    # Display final versions only if we installed something
    if [ "$installed_something" = true ]; then
        printf '%s\n' "Final versions:"
        if command -v nvm >/dev/null 2>&1; then
            case "$(uname -s 2>/dev/null)" in
                MINGW*|MSYS*|CYGWIN*)
                    printf 'nvm: %s\n' "$(nvm version 2>/dev/null || echo 'N/A')"
                    ;;
                *)
                    printf 'nvm: %s\n' "$(nvm --version 2>/dev/null || echo 'N/A')"
                    ;;
            esac
        fi
        printf 'node: %s\n' "$(node --version 2>/dev/null || echo 'N/A')"
        printf 'npm: %s\n' "$(npm --version 2>/dev/null || echo 'N/A')"
        if command -v pnpm >/dev/null 2>&1; then
            printf 'pnpm: %s\n' "$(pnpm --version 2>/dev/null || echo 'N/A')"
        fi
        if command -v bun >/dev/null 2>&1; then
            printf 'bun: %s\n' "$(bun --version 2>/dev/null || echo 'N/A')"
        fi
    fi
}

installJavaEnv() {
    local installed_something=false
    local sdkman_dir="$HOME/.sdkman"

    # Display current versions immediately (instant feedback)
    if [ -s "$sdkman_dir/bin/sdkman-init.sh" ]; then
        export SDKMAN_DIR="$sdkman_dir"
        # shellcheck source=/dev/null
        [ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ] && \. "$SDKMAN_DIR/bin/sdkman-init.sh" 2>/dev/null || true
    fi

    if command -v java >/dev/null 2>&1; then
        printf 'java: %s\n' "$(java -version 2>&1 | head -n 1 | cut -d'"' -f2 || echo 'N/A')"
    else
        printf 'java: not installed\n'
    fi
    if command -v mvn >/dev/null 2>&1; then
        printf 'maven: %s\n' "$(mvn --version 2>&1 | head -n 1 | sed 's/.*Maven //' | cut -d' ' -f1 || echo 'N/A')"
    else
        printf 'maven: not installed\n'
    fi

    # Install SDKMAN if needed
    if [ ! -s "$sdkman_dir/bin/sdkman-init.sh" ]; then
        if ! command -v curl >/dev/null 2>&1; then
            echo "Java environment setup requires curl." >&2
            return 1
        fi

        # Install required dependencies (zip and unzip)
        if ! command -v zip >/dev/null 2>&1 || ! command -v unzip >/dev/null 2>&1; then
            echo "Installing zip and unzip (required for SDKMAN)..." >&2
            case "$(uname -s 2>/dev/null)" in
                Linux*)
                    if command -v apt-get >/dev/null 2>&1; then
                        sudo apt-get update -y >/dev/null 2>&1 && sudo apt-get install -y zip unzip >/dev/null 2>&1 || {
                            echo "✗ Failed to install zip/unzip. Please install manually: sudo apt-get install -y zip unzip" >&2
                            return 1
                        }
                    elif command -v yum >/dev/null 2>&1; then
                        sudo yum install -y zip unzip >/dev/null 2>&1 || {
                            echo "✗ Failed to install zip/unzip. Please install manually: sudo yum install -y zip unzip" >&2
                            return 1
                        }
                    elif command -v pacman >/dev/null 2>&1; then
                        sudo pacman -S --noconfirm zip unzip >/dev/null 2>&1 || {
                            echo "✗ Failed to install zip/unzip. Please install manually: sudo pacman -S zip unzip" >&2
                            return 1
                        }
                    else
                        echo "✗ Could not determine package manager. Please install zip and unzip manually." >&2
                        return 1
                    fi
                    ;;
                Darwin*)
                    if command -v brew >/dev/null 2>&1; then
                        brew install zip unzip >/dev/null 2>&1 || {
                            echo "✗ Failed to install zip/unzip. Please install manually: brew install zip unzip" >&2
                            return 1
                        }
                    else
                        echo "✗ Homebrew not found. Please install zip and unzip manually." >&2
                        return 1
                    fi
                    ;;
                *)
                    echo "✗ Unsupported OS. Please install zip and unzip manually." >&2
                    return 1
                    ;;
            esac
        fi

        echo "Installing SDKMAN..." >&2
        curl -s "https://get.sdkman.io" | bash || {
            echo "✗ Failed to install SDKMAN" >&2
            return 1
        }

        # Source SDKMAN
        export SDKMAN_DIR="$sdkman_dir"
        # shellcheck source=/dev/null
        [ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ] && \. "$SDKMAN_DIR/bin/sdkman-init.sh" || {
            echo "✗ Failed to source SDKMAN" >&2
            return 1
        }
        installed_something=true
    else
        # Source SDKMAN if already installed
        export SDKMAN_DIR="$sdkman_dir"
        # shellcheck source=/dev/null
        [ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ] && \. "$SDKMAN_DIR/bin/sdkman-init.sh" 2>/dev/null || true
    fi

    # Install Java (default)
    if ! command -v java >/dev/null 2>&1; then
        echo "Installing Java..." >&2
        yes | sdk install java 2>/dev/null || {
            echo "✗ Failed to install Java" >&2
            return 1
        }
        installed_something=true
    fi

    # Install Maven (default)
    if ! command -v mvn >/dev/null 2>&1; then
        echo "Installing Maven..." >&2
        yes | sdk install maven 2>/dev/null || {
            echo "✗ Failed to install Maven" >&2
            return 1
        }
        installed_something=true
    fi

    # Ensure SDKMAN is loaded
    export SDKMAN_DIR="$sdkman_dir"
    # shellcheck source=/dev/null
    [ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ] && \. "$SDKMAN_DIR/bin/sdkman-init.sh" 2>/dev/null || true

    # Display final versions only if we installed something
    if [ "$installed_something" = true ]; then
        printf '%s\n' "Final versions:"
        if command -v java >/dev/null 2>&1; then
            printf 'java: %s\n' "$(java -version 2>&1 | head -n 1 | cut -d'"' -f2 || echo 'N/A')"
        fi
        if command -v mvn >/dev/null 2>&1; then
            printf 'maven: %s\n' "$(mvn --version 2>&1 | head -n 1 | sed 's/.*Maven //' | cut -d' ' -f1 || echo 'N/A')"
        fi
    fi
}

claude() {
    if [ ! -d ~/ai ]; then
        git clone git@github.com:judigot/ai.git ~/ai >/dev/null 2>&1
    else
        git -C ~/ai pull >/dev/null 2>&1
    fi

    command claude --plugin-dir ~/ai --plugin-dir . "$@"
}

opencode() {
    BASH_ENV="$HOME/.bashrc" command opencode "$@"
}

# Check if a package/command is installed (silent check)
# Usage: installPackage <package_name>
installPackage() {
    local package="$1"

    if [ -z "$package" ]; then
        return 1
    fi

    command -v "$package" >/dev/null 2>&1
}

msysInstallPackage() {
    local package="$1"

    if [ -z "$package" ] || ! command -v pacman >/dev/null 2>&1; then
        return 1
    fi

    case "${MSYSTEM:-}" in
        MINGW64|UCRT64|CLANG64|CLANGARM64)
            pacman -S --needed --noconfirm "mingw-w64-x86_64-$package"
            ;;
        *)
            pacman -S --needed --noconfirm "$package"
            ;;
    esac
}

# Ubuntu-like apt wrapper for pacman
# Usage: apt <command> [options] [packages]
apt() {
    # If pacman is not available, fall back to real apt
    if ! command -v pacman >/dev/null 2>&1; then
        command apt "$@"
        return $?
    fi

    local cmd="$1"
    shift

    # Process -y flag: convert to --noconfirm for pacman
    local args=()
    local use_noconfirm=false

    for arg in "$@"; do
        if [ "$arg" = "-y" ] || [ "$arg" = "--yes" ]; then
            use_noconfirm=true
        else
            args+=("$arg")
        fi
    done

    # Build pacman command with conditional --noconfirm
    local pacman_args=()
    [ "$use_noconfirm" = true ] && pacman_args+=("--noconfirm")

    case "$cmd" in
        install)
            pacman -S "${pacman_args[@]}" "${args[@]}"
            ;;
        update)
            pacman -Sy "${pacman_args[@]}" "${args[@]}"
            ;;
        upgrade)
            pacman -Syu "${pacman_args[@]}" "${args[@]}"
            ;;
        search)
            pacman -Ss "${args[@]}"
            ;;
        remove)
            pacman -Rs "${pacman_args[@]}" "${args[@]}"
            ;;
        autoremove)
            local orphans=""
            orphans=$(pacman -Qdtq 2>/dev/null) || orphans=""

            if [ -z "$orphans" ]; then
                return 0
            fi

            # shellcheck disable=SC2086
            pacman -Rns "${pacman_args[@]}" $orphans "${args[@]}"
            ;;
        list)
            if [ "${args[0]}" = "--installed" ]; then
                pacman -Q "${args[@]:1}"
            else
                pacman -Sl "${args[@]}"
            fi
            ;;
        show)
            pacman -Si "${args[@]}"
            ;;
        clean)
            pacman -Sc "${pacman_args[@]}" "${args[@]}"
            ;;
        *)
            command apt "$cmd" "$@"
            ;;
    esac
}

useAI() {
    local choices=("Claude Code" "Codex CLI" "Open Code")
    local selected

    selected=$(arrowKeySelect "Select AI (↑↓ arrows, Enter to select, q to quit):" "${choices[@]}")

    if [ -z "$selected" ]; then
        return 130
    fi

    case "$selected" in
        "Claude Code")
            if ! installPackage "claude"; then
                printf '%s\n' "Claude Code is not installed, installing..." >&2
                installClaudeCode
                if ! installPackage "claude"; then
                    printf '%s\n' "Failed to install Claude Code" >&2
                    return 1
                fi
            fi
            claude "$@"
            ;;
        "Open Code")
            if ! installPackage "opencode"; then
                printf '%s\n' "Open Code is not installed, installing..." >&2
                installOpenCode
                if ! installPackage "opencode"; then
                    printf '%s\n' "Failed to install Open Code" >&2
                    return 1
                fi
            fi
            opencode "$@"
            ;;
        "Codex CLI")
            if ! installPackage "codex"; then
                printf '%s\n' "Codex CLI is not installed, installing..." >&2
                installCodexCLI
                if ! installPackage "codex"; then
                    printf '%s\n' "Failed to install Codex CLI" >&2
                    return 1
                fi
            fi
            codex "$@"
            ;;
    esac
}

addCursorBoilerplate() {
    downloadGithubRepo judigot/cursor
}

# Download GitHub repo without cloning (no .git)
# Usage: downloadGithubRepo <user/repo> [branch] [target_dir]
# Example: downloadGithubRepo judigot/cursor main .
downloadGithubRepo() {
    local repo="$1"
    local branch="${2:-main}"
    local target="${3:-.}"
    
    if [ -z "$repo" ]; then
        echo "Usage: downloadGithubRepo <user/repo> [branch] [target_dir]"
        return 1
    fi
    
    local name="${repo#*/}"
    local url="https://github.com/$repo/archive/refs/heads/$branch.zip"

    local tmp_dir
    tmp_dir=$(mktemp -d "/tmp/${name}.XXXXXXXX") || return 1

    local zip="$tmp_dir/$name.zip"

    if ! curl -fsSL --retry 3 --retry-delay 1 "$url" -o "$zip" 2>/dev/null; then
        printf '%s\n' "Download failed" >&2
        rm -rf "$tmp_dir" 2>/dev/null || true
        return 1
    fi

    if [ ! -s "$zip" ]; then
        printf '%s\n' "Download failed (empty archive)" >&2
        rm -rf "$tmp_dir" 2>/dev/null || true
        return 1
    fi

    if ! unzip -q "$zip" -d "$tmp_dir" 2>/dev/null; then
        printf '%s\n' "Extract failed" >&2
        rm -rf "$tmp_dir" 2>/dev/null || true
        return 1
    fi
    
    mv "$tmp_dir/$name-$branch"/* "$target/" 2>/dev/null
    mv "$tmp_dir/$name-$branch"/.[!.]* "$target/" 2>/dev/null
    rm -rf "$tmp_dir"
    
    echo "Downloaded $repo to $target"
}

# Download files from GitHub repo (no caching issues, supports nested paths)
# Usage: downloadGithubFiles <user/repo> [files...] [--dest dir] [--branch name]
# Example: downloadGithubFiles judigot/user .bashrc .zshrc .devrc
# Example: downloadGithubFiles judigot/user src/index.ts --dest ./src --branch develop
downloadGithubFiles() {
    local repo=""
    local dest="."
    local branch="main"
    local files=()
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --dest) dest="$2"; shift 2 ;;
            --branch) branch="$2"; shift 2 ;;
            *)
                if [ -z "$repo" ]; then
                    repo="$1"
                else
                    files+=("$1")
                fi
                shift ;;
        esac
    done
    
    if [ -z "$repo" ] || [ ${#files[@]} -eq 0 ]; then
        echo "Usage: downloadGithubFiles <user/repo> [files...] [--dest dir] [--branch name]"
        return 1
    fi
    
    # Raw-only download to avoid stale zip caches.
    # Old zip-based implementation removed for freshness.
    local downloaded=0
    for file in "${files[@]}"; do
        [ -n "$file" ] || continue
        local dest_path="$dest/$file"
        local cache_bust=""
        cache_bust=$(date +%s 2>/dev/null || echo "0")
        mkdir -p "$(dirname "$dest_path")"
        if curl -fsSL -H "Cache-Control: no-cache" -H "Pragma: no-cache" \
            "https://raw.githubusercontent.com/$repo/$branch/$file?cachebust=$cache_bust" \
            -o "$dest_path" 2>/dev/null; then
            downloaded=$((downloaded + 1))
        else
            printf '%s\n' "Download failed: $file" >&2
            return 1
        fi
    done

    echo "Downloaded ${downloaded} file(s) to $dest"
}

#<TERMUX>
termuxInstallUbuntu() {
    pkg update -y && pkg upgrade -y
    pkg install -y proot-distro
    proot-distro install ubuntu
}

termuxLoginUbuntu() {
    proot-distro login ubuntu
}
#</TERMUX>

#<AGENT_ALIASES>
gc() { git add -A && git status && git commit -m "$1"; }  # Git commit: stage all, show status, commit with message (no push)
gcp() { git add -A && git status; }                       # Git commit preview: stage all and show what would be committed
gpr() { gh pr create --fill; }                            # GitHub PR: create pull request with auto-filled title/body
nr() { bun run "$1"; }                                    # Node run: execute a script from package.json using Bun
#</AGENT_ALIASES>

loadAliasFile
